# vim: ft=gitconfig

[user]
  name = Shane Smith
  email = shane.wm.smith@gmail.com

[alias]
# Abbreviations
  s = status
  st = status
  stuart = status
  shoe = show
  br = branch
  co = checkout
  pop = stash pop
  unstage = reset HEAD
  df = diff
  staged = diff --staged
  sg = diff --staged
  top = rev-parse --show-toplevel
  gerrit = !gerrit
  git = !git
  wdiff = diff --color-words
  wshow = show --color-words
  wshoe = !git wshow
  amend = commit --amend
  wip = commit -m 'wip'
  unwip = reset HEAD^
  hardhead = reset --hard HEAD
  hardup = reset --hard @{u}
  pick = cherry-pick
  for = fetch origin
  rb = rebase
  irb = rebase -i
  continue = rebase --continue
  stat = show --name-status
  base = merge-base HEAD
  pa = add -p
  ua = add -u
  AA = add -A
  por = push -u origin HEAD
  puf = push -f
  rom = rebase origin/master

# Log
  lol = "!f() { local extra=\"\"; if git rev-parse -q --verify '@{u}' >/dev/null 2>&1; then extra=\"$extra @{u}\"; fi; git log --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %C(yellow)<%an, %cd>%Creset %s' --color --graph --date=relative --branches --remotes=origin/[m]aster HEAD $extra $@; }; f"
  lolb = "!f() { local extra=\"\"; if git rev-parse -q --verify '@{u}' >/dev/null 2>&1; then extra=\"$extra @{u}\"; fi; git log --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %C(yellow)<%an, %cd>%Creset %s' --color --graph --date=relative HEAD $extra $@; }; f"
  lolf = "!f() { local extra=\"\"; if git rev-parse -q --verify '@{u}' >/dev/null 2>&1; then extra=\"$extra @{u}\"; fi; git log --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %C(yellow)<%an, %cd>%Creset %s' --color --graph --date=relative --name-status --branches --remotes=origin/[m]aster HEAD $extra $@; }; f"
  lolbf = "!f() { local extra=\"\"; if git rev-parse -q --verify '@{u}' >/dev/null 2>&1; then extra=\"$extra @{u}\"; fi; git log --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %C(yellow)<%an, %cd>%Creset %s' --color --graph --date=relative --name-status HEAD $extra $@; }; f"
  lolnew = log --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %C(yellow)<%an, %cr>%Creset %s' --graph ORIG_HEAD..
  lall = log --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %C(yellow)<%an, %cr>%Creset %s' --graph --all
  lallf = log --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %C(yellow)<%an, %cr>%Creset %s' --graph --all --name-status
  logf = log --name-status
  k = !gitk --all >/dev/null 2>&1 &
  who= shortlog -s
  whatdidido = log --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %C(yellow)<%an, %cd>%Creset %s' --graph --all --date=short --author=Shane
  rescue = !git fsck --full --no-reflogs --unreachable --lost-found | grep commit | cut -d' ' -f3 | xargs git log --pretty=oneline

# Git-SVN
  slog = svn log --show-commit
  slogf = svn log --show-commit --verbose
  slol = svn log --show-commit --oneline
  sshow = "!f() { git show $(git svn find-rev r$1); }; f" # git sshow <rev>
  scheckout = "!f() { git checkout $(git svn find-rev r$1); }; f"
  sco = !git scheckout

# Special ignore
  assume-unchanged = update-index --assume-unchanged --
  no-assume-unchanged = update-index --no-assume-unchanged --
  show-assume-unchanged = !git ls-files -v | grep \"^[[:lower:]]\"
  skip-worktree = update-index --skip-worktree --
  no-skip-worktree = update-index --no-skip-worktree --
  show-skip-worktree = !git ls-files -v | grep \"^S\"

# Edit conflicts
  vc = "!vim $(git status --porcelain | awk '/^(UU|AA)/ { print $2 }')"
  mvc = "!mvim $(git status --porcelain | awk '/^(UU|AA)/ { print $2 }')"

# Submodules
  remove-submodule = "!f() { if [ -d $1 ]; then echo "Removing from .gitmodule..."; git config -f .gitmodules --remove-section submodule.$1; echo "Removing from .git/config..."; git config -f .git/config --remove-section submodule.$1; echo "Removing from cache..."; git rm --cached $1; fi }; f"
  delete-submodule = "!f() { if [ -d $1 ]; then echo "Removing from .gitmodule..."; git config -f .gitmodules --remove-section submodule.$1; echo "Removing from .git/config..."; git config -f .git/config --remove-section submodule.$1; echo "Removing from cache..."; git rm --cached $1; echo "Removing directory..."; rm -rf $1; fi }; f"
  remove-merged-branches = "!git_remove-merged-branches"

# Branch
  bracoa = "!f() { git checkout -b \"$1\" && git commit -a -m \"${2:-wip}\" && git checkout -; }; f"
  bracop = "!f() { git checkout -b \"$1\" && git add -p && git commit -m \"${2:-wip}\" && git checkout -; }; f"
  cob = "!f() { git checkout $(git show-ref --verify --quiet refs/heads/\"$1\" || echo '-b') \"$1\" $2; }; f"
  newb = "!f(){ upbranch=${2:-$(git rev-parse --symbolic-full-name --abbrev-ref '@{u}')}; git checkout -b \"$1\"; git branch -u \"$upbranch\"; }; f"
  hs = "!f(){ git log -g --oneline -n${1:-100} | awk '/checkout:/ { if (system(\"git show-ref --quiet --verify refs/heads/\"$NF) == 0) print substr($2, 7)\" \"$NF }' | sort -k2 -u | sort -k1 -n | tail +2 | cut -d' ' -f2; }; f"
  pup = "!f(){ [ $# -eq 1 ] && git checkout $1 && git pull && git co -; }; f"
  mup = "!f(){ [ $# -eq 1 ] && git checkout $1 && git merge && git co -; }; f"
  sweep = "!f() { echo \"Would delete branches:\"; git branch --merged ${1:-HEAD} | grep -v -e '^\\*' -e '^  *master$'; }; f"
  sweepit = "!f() { git branch --merged ${1:-HEAD} | grep -v -e '^\\*' -e '^  *master$' | xargs git branch -d; }; f"
  sweep-remote = "!f() { echo \"Would delete branches:\"; git branch --remote --merged ${1:-HEAD} | grep -v -e '^ *origin/HEAD' -e '^  *origin/master$'; }; f"
  sweep-remote-it = "!f() { git branch --remote --merged ${1:-HEAD} | grep -v -e '^ *origin/HEAD' -e '^  *origin/master$' | xargs git branch --remote -d; }; f"
  upstream = "!f() { git branch --set-upstream-to=\"$1\"; }; f"
  topic = "!gerrit topic"

# Commit
  cc = "!f() { if [ -n \"$1\" ]; then git commit -m \"$1\"; else git commit; fi; }; f"
  cca = "!f() { if [ -n \"$1\" ]; then git commit -a -m \"$1\"; else git commit -a; fi; }; f"

# Stash
  force-stash-apply = "!f() { git stash show -p ${1} | git apply; }; f"
  mash = "!f() { git stash && git merge $1 && git stash pop; }; f"
  rash = "!f() { git stash && git rebase $1 && git stash pop; }; f"
  cash = "!f() { git stash && git checkout $1 && git stash pop; }; f"

# Misc
  this = "!f() { git init && git add . && git commit -m \"${1:-FIRST}\"; }; f"
  ignore = "!f() { echo $1 >> .gitignore; }; f"
  grep-add = "!f() { git ls-files -m -o --exclude-standard | grep \"$1\" | xargs git add --; }; f"
  er-done = "!f() { git commit -m \"$1\" && git push; }; f"
  rmerge = "!f() { git rebase \"origin/$1\" && git checkout \"$1\" && git merge -; }; f"
  fixup = "!f() { if [[ -n \"$1\" && ! \"$1\" =~ ^-  ]]; then git commit --fixup=\"$1\" \"${@:2}\" ; else git commit --amend --reuse-message=HEAD \"$@\"; fi; }; f"
  rb-current-commit = "!cat .git/rebase-apply/original-commit"
  rb-diff-ours = "!git show $(git rb-current-commit)"
  rb-diff-theirs = "!git diff $(git base $(git rb-current-commit)) HEAD"

# Github
  pr = "!f() { git fetch origin pull/$1/head:pr/$1 && git checkout pr/$1; }; f"

[color]
  ui = auto

[core]
  editor = vim
  excludesfile = ~/.gitignore

[merge]
  defaultToUpstream = true
  conflictStyle = diff3

[push]
  default = tracking  # deprecated, update to "upstream" when removed

[rebase]
  autosquash = true

[diff]
  algorithm = histogram

[tig "bind"]
  main = C <git checkout %(commit)

[gerrit "default"]
	host = partners.macadamian.com
	port = 29418
	user = ssmith
