#!/bin/bash

__readline_insert() {
  READLINE_LINE="${READLINE_LINE:0:$READLINE_POINT}$1${READLINE_LINE:$READLINE_POINT}"
  READLINE_POINT=$(( $READLINE_POINT + ${#1} ))
}

__readline_replace() {
  READLINE_LINE="$1"
  READLINE_POINT="${#1}"
}

__escape() {
  while read -r item; do 
    printf '%q ' "$item"
  done
}

_fzf_git_lol() {
  # TODO always describe?
  local sha="$(git lol | fzf --ansi --reverse --no-sort --tiebreak=index --multi | grep -owE '^.*?[a-z0-9]{7}' | grep -oE '.{7}$' | xargs git describe --all --contains | tr '\n' ' ')"
  __readline_insert "$sha"
}

_fzf_git_status() {
  local file="$(git status --short | fzf -m | awk '{print $2}' | __escape)"
  __readline_insert "$file"
}

_fzf_git_status_untracked() {
  local file="$(git status --short | grep -O '^??' | fzf -m | awk '{print $2}' | __escape)"
  __readline_insert "$file"
}

_fzf_git_history() {
  local branch=$(git hs | fzf)
  __readline_insert "$branch"
}

_fzf_git_branch() {
  local branch=$(git for-each-ref --format="%(refname:short)" refs/heads/ | fzf -m | __escape)
  __readline_insert "$branch"
}

_fzf_git_reflog() {
  local sha="$(git reflog --color | fzf --ansi --no-sort | awk '{print $1}' | __escape)"
  __readline_insert "$sha"
}

_fzf_history() { 
  local line
  shopt -u nocaseglob nocasematch
  line=$(HISTTIMEFORMAT= history | fzf --no-sort --tac +m -n2..,.. --tiebreak=index --toggle-sort=ctrl-r | awk '{ $1=""; print $0 }' | sed 's/^ *//')
  __readline_replace "$line"
}

_fzf_files() {
  local file="$(fzf -m | __escape)"
  if [[ -n $file ]]; then
    __readline_insert "$file"
  fi
}

_fzf_cd() {
  # TODO extract current word to use as basis for find
  local dir=$(command find -L . \( -path '*/\.*' -o -fstype 'devfs' -o -fstype 'devtmpfs' -o -fstype 'proc' \) -prune -o -type d -print 2> /dev/null | sed 1d | cut -b3- | fzf)
  __readline_replace "cd ${dir}"
}

_fzf_gerrit_patch() {
  local id=$(gerrit patches | fzf --header-lines=1 --reverse | awk '{print $1}')
  __readline_insert "$id"
}

_fzf_word() {
  local cmd

  local word=$(echo "${READLINE_LINE:0:$READLINE_POINT}" | awk '{print $NF}')

  case "$word" in
    f) cmd="_fzf_files" ;;
    gl)  cmd="_fzf_git_lol" ;;
    gs)  cmd="_fzf_git_status" ;;
    gsu)  cmd="_fzf_git_status_untracked" ;;
    gh)  cmd="_fzf_git_history" ;;
    grp) cmd="_fzf_gerrit_patch" ;;
    gb) cmd="_fzf_git_branch" ;;
    gr) cmd="_fzf_git_reflog" ;;
    *)   cmd="_fzf_${word}" ;;
  esac

  if ! type -t "$cmd" >/dev/null; then
    return
  fi

  READLINE_LINE="${READLINE_LINE:0:(($READLINE_POINT - ${#word}))}${READLINE_LINE:$READLINE_POINT}"
  READLINE_POINT="$(($READLINE_POINT - ${#word}))"

  eval "$cmd"
}

if command -v fzf >/dev/null; then
  bind -x '"\C-r": _fzf_history'
  bind -x '"\C-ff": _fzf_files'
  bind -x '"\C-f\C-f": _fzf_word'
  bind -x '"\C-fg": _fzf_git_lol'
  bind -x '"\C-fc": _fzf_cd'
  bind -x '"\C-fp": _fzf_gerrit_patch'
  bind -x '"\C-fs": _fzf_git_status'
  bind -x '"\C-fw": _fzf_word'
fi

